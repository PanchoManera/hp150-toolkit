name: Build HP-150 Toolkit Binaries

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'
  PYINSTALLER_ARGS: '--paths=src --hidden-import=gui.hp150_gui --hidden-import=gui.hp150_gui_extended --hidden-import=gui.config_manager --hidden-import=gui.greasewazle_config_dialog --hidden-import=tools.hp150_fat'

jobs:
  build:
    name: Build on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            artifact-name: 'hp150-toolkit-macos'
            exe-name: 'HP150-Toolkit.app'
            icon: 'üçé'
            platform: 'macOS'
            build-type: 'windowed'
            
          - os: windows-latest
            artifact-name: 'hp150-toolkit-windows'
            exe-name: 'HP150-Toolkit.exe'
            icon: 'ü™ü'
            platform: 'Windows'
            build-type: 'onefile'
            
          - os: ubuntu-latest
            artifact-name: 'hp150-toolkit-linux'
            exe-name: 'HP150-Toolkit'
            icon: 'üêß'
            platform: 'Linux'
            build-type: 'onefile'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install system dependencies
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          sudo apt-get update
          sudo apt-get install -y python3-tk
        elif [ "$RUNNER_OS" == "Windows" ]; then
          # Windows Python from actions/setup-python includes tkinter by default
          echo "Windows: tkinter should be available by default"
        fi
      shell: bash
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
        # Install Pillow for icon creation (macOS only, but doesn't hurt on other platforms)
        pip install Pillow
    
    - name: Create application icon (macOS only)
      if: runner.os == 'macOS'
      run: |
        # Create a simple icon for the macOS bundle
        echo "üé® Creating application icon for macOS..."
        
        # Create icon directory
        mkdir -p icon_temp
        
        # Create a simple PNG icon (this is just a placeholder)
        # In a real scenario, you'd have an actual icon file
        python -c "
from PIL import Image, ImageDraw, ImageFont
import os

# Create a simple 512x512 icon
size = 512
img = Image.new('RGBA', (size, size), (70, 130, 180, 255))  # Steel blue background
draw = ImageDraw.Draw(img)

# Draw a simple computer/floppy disk icon
rect_color = (255, 255, 255, 255)  # White
# Main rectangle (computer/floppy)
draw.rectangle([100, 150, 412, 400], fill=rect_color, outline=(0, 0, 0, 255), width=3)
# Slot for disk
draw.rectangle([130, 180, 382, 220], fill=(0, 0, 0, 255))
# Label area
draw.rectangle([150, 240, 362, 280], fill=(200, 200, 200, 255))
# Text
try:
    font = ImageFont.truetype('/System/Library/Fonts/Arial.ttf', 36)
except:
    font = ImageFont.load_default()
draw.text((size//2, 320), 'HP-150', fill=(0, 0, 0, 255), font=font, anchor='mm')
draw.text((size//2, 360), 'Toolkit', fill=(0, 0, 0, 255), font=font, anchor='mm')

# Save as PNG
img.save('icon_temp/icon.png')
print('Icon created successfully')
" 2>/dev/null || echo "Could not create custom icon, will use default"
        
        # Convert PNG to ICNS if we have iconutil (macOS)
        if [ -f "icon_temp/icon.png" ]; then
          echo "üîÑ Converting PNG to ICNS..."
          mkdir -p icon_temp/AppIcon.iconset
          
          # Create different sizes for the iconset
          if command -v sips >/dev/null 2>&1; then
            sips -z 16 16 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_16x16.png
            sips -z 32 32 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_16x16@2x.png
            sips -z 32 32 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_32x32.png
            sips -z 64 64 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_32x32@2x.png
            sips -z 128 128 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_128x128.png
            sips -z 256 256 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_128x128@2x.png
            sips -z 256 256 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_256x256.png
            sips -z 512 512 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_256x256@2x.png
            sips -z 512 512 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_512x512.png
            sips -z 1024 1024 icon_temp/icon.png --out icon_temp/AppIcon.iconset/icon_512x512@2x.png
            
            # Create ICNS file
            iconutil -c icns icon_temp/AppIcon.iconset -o app_icon.icns
            echo "‚úÖ ICNS icon created: app_icon.icns"
          else
            echo "‚ö†Ô∏è sips not available, using PNG icon directly"
            cp icon_temp/icon.png app_icon.png
          fi
        else
          echo "‚ö†Ô∏è No icon created, will use default PyInstaller icon"
        fi
    
    - name: Debug import (Windows only)
      if: runner.os == 'Windows'
      run: |
        echo "Testing imports..."
        python -c "import sys; print('Python version:', sys.version)"
        python -c "import tkinter; print('‚úÖ tkinter available')"
        python -c "import sys; print('Python path:', sys.path[:3])"
        echo "Current directory structure:"
        dir /s /b src\gui
        python -c "import sys; sys.path.insert(0, 'src'); from gui.hp150_gui import HP150ImageManager; print('‚úÖ HP150ImageManager import successful')"
        python -c "import sys; sys.path.insert(0, 'src'); from gui.hp150_gui_extended import HP150ImageManagerExtended; print('‚úÖ HP150ImageManagerExtended import successful')"
        echo "‚úÖ All imports successful"
    
    - name: Build executable
      run: |
        BUILD_CMD="pyinstaller --name=HP150-Toolkit ${{ env.PYINSTALLER_ARGS }}"
        
        # Add OS-specific flags
        if [ "${{ matrix.build-type }}" == "windowed" ]; then
          BUILD_CMD="$BUILD_CMD --windowed --add-data=src:src --add-data=scripts:scripts --noconsole"
          # macOS-specific options for proper bundle generation
          if [ "$RUNNER_OS" == "macOS" ]; then
            BUILD_CMD="$BUILD_CMD --osx-bundle-identifier=com.hp150toolkit.app"
            # Add icon if available
            if [ -f "app_icon.icns" ]; then
              BUILD_CMD="$BUILD_CMD --icon=app_icon.icns"
              echo "‚úÖ Using custom ICNS icon"
            elif [ -f "app_icon.png" ]; then
              BUILD_CMD="$BUILD_CMD --icon=app_icon.png"
              echo "‚úÖ Using PNG icon"
            fi
          fi
        elif [ "${{ matrix.build-type }}" == "onefile" ]; then
          BUILD_CMD="$BUILD_CMD --onefile"
          if [ "$RUNNER_OS" == "Linux" ]; then
            BUILD_CMD="$BUILD_CMD --add-data=src:src --add-data=scripts:scripts"
          elif [ "$RUNNER_OS" == "Windows" ]; then
            BUILD_CMD="$BUILD_CMD --console --add-data=src;src --add-data=scripts;scripts"
            # Windows-specific hidden imports for tkinter
            BUILD_CMD="$BUILD_CMD --hidden-import=tkinter --hidden-import=tkinter.filedialog --hidden-import=tkinter.messagebox --hidden-import=tkinter.ttk"
          fi
        fi
        
        BUILD_CMD="$BUILD_CMD run_gui.py"
        echo "üî® Running: $BUILD_CMD"
        eval $BUILD_CMD
      shell: bash
    
    - name: Prepare distribution
      run: |
        mkdir -p dist-final
        
        # Copy executable
        if [ "$RUNNER_OS" == "macOS" ]; then
          # Copy macOS bundle
          cp -r "dist/${{ matrix.exe-name }}" dist-final/
          
          # Fix macOS bundle structure and permissions
          echo "üîß Fixing macOS bundle structure..."
          
          # Ensure proper bundle structure
          BUNDLE_PATH="dist-final/${{ matrix.exe-name }}"
          
          # Fix Info.plist if it exists
          if [ -f "$BUNDLE_PATH/Contents/Info.plist" ]; then
            echo "‚úÖ Info.plist found"
            # Ensure bundle identifier is set
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier com.hp150toolkit.app" "$BUNDLE_PATH/Contents/Info.plist" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleIdentifier string com.hp150toolkit.app" "$BUNDLE_PATH/Contents/Info.plist"
            
            # Set bundle version
            /usr/libexec/PlistBuddy -c "Set :CFBundleVersion 1.6.1" "$BUNDLE_PATH/Contents/Info.plist" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string 1.6.1" "$BUNDLE_PATH/Contents/Info.plist"
            
            # Set short version
            /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString 1.6.1" "$BUNDLE_PATH/Contents/Info.plist" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string 1.6.1" "$BUNDLE_PATH/Contents/Info.plist"
          else
            echo "‚ö†Ô∏è Creating minimal Info.plist"
            mkdir -p "$BUNDLE_PATH/Contents"
            cat > "$BUNDLE_PATH/Contents/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>HP150-Toolkit</string>
            <key>CFBundleIdentifier</key>
            <string>com.hp150toolkit.app</string>
            <key>CFBundleName</key>
            <string>HP150-Toolkit</string>
            <key>CFBundleVersion</key>
            <string>1.6.1</string>
            <key>CFBundleShortVersionString</key>
            <string>1.6.1</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
        </dict>
        </plist>
        EOF
          fi
          
          # Fix executable permissions
          if [ -f "$BUNDLE_PATH/Contents/MacOS/HP150-Toolkit" ]; then
            echo "üîß Setting executable permissions..."
            chmod +x "$BUNDLE_PATH/Contents/MacOS/HP150-Toolkit"
            echo "‚úÖ Executable permissions set"
          else
            echo "‚ö†Ô∏è Main executable not found, checking alternative locations..."
            find "$BUNDLE_PATH" -name "HP150-Toolkit" -type f -exec chmod +x {} \;
          fi
          
          # Remove quarantine attributes (helps with unsigned apps)
          echo "üîß Removing quarantine attributes..."
          xattr -cr "$BUNDLE_PATH" 2>/dev/null || echo "‚ö†Ô∏è Could not remove quarantine attributes"
          
          # Verify bundle structure
          echo "üìÅ Bundle structure:"
          find "$BUNDLE_PATH" -type f | head -10
          
          echo "‚úÖ macOS bundle prepared"
          
          # Test bundle validity
          echo "üß™ Testing bundle validity..."
          if [ -f "$BUNDLE_PATH/Contents/MacOS/HP150-Toolkit" ]; then
            echo "‚úÖ Main executable exists"
            file "$BUNDLE_PATH/Contents/MacOS/HP150-Toolkit"
            ls -la "$BUNDLE_PATH/Contents/MacOS/HP150-Toolkit"
          else
            echo "‚ùå Main executable not found!"
            echo "Bundle contents:"
            find "$BUNDLE_PATH" -type f
          fi
          
          # Create a simple test script
          echo "#!/bin/bash" > "$BUNDLE_PATH/test_bundle.sh"
          echo "echo 'Bundle test - can execute scripts'" >> "$BUNDLE_PATH/test_bundle.sh"
          chmod +x "$BUNDLE_PATH/test_bundle.sh"
          
        elif [ "$RUNNER_OS" == "Windows" ]; then
          cp "dist/${{ matrix.exe-name }}" dist-final/
        else
          cp "dist/${{ matrix.exe-name }}" dist-final/
        fi
        
        # Create HOW_TO_RUN.txt
        echo "${{ matrix.icon }} ${{ matrix.platform }} Executable" > dist-final/HOW_TO_RUN.txt
        
        if [ "$RUNNER_OS" == "macOS" ]; then
          echo "Run: Double-click ${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
          echo "Terminal: open ${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
        elif [ "$RUNNER_OS" == "Windows" ]; then
          echo "Run: Double-click ${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
          echo "Terminal: .\\${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
        else
          echo "Run: ./${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
          echo "Make executable: chmod +x ${{ matrix.exe-name }}" >> dist-final/HOW_TO_RUN.txt
        fi
        
        echo "" >> dist-final/HOW_TO_RUN.txt
        echo "Modes:" >> dist-final/HOW_TO_RUN.txt
        echo "  ‚Ä¢ Extended (default): Full functionality" >> dist-final/HOW_TO_RUN.txt
        echo "  ‚Ä¢ Basic: Add --basic flag" >> dist-final/HOW_TO_RUN.txt
      shell: bash
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}
        path: dist-final/
        retention-days: 30
  
  release:
    name: Create Release
    if: startsWith(github.ref, 'refs/tags/')
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
    
    - name: Prepare release files
      run: |
        mkdir -p release/
        
        # Create zip files for each platform
        cd artifacts/
        for dir in */; do
          platform=$(echo "$dir" | sed 's/-toolkit-/-/' | sed 's|/$||')
          echo "üì¶ Creating $platform.zip"
          cd "$dir"
          zip -r "../../release/$platform.zip" .
          cd ..
        done
        
        cd ../release/
        ls -la
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: release/*.zip
        name: "HP-150 Toolkit ${{ github.ref_name }}"
        body: |
          ## üöÄ HP-150 Toolkit - Release ${{ github.ref_name }}
          
          ### ‚ú® Nuevas caracter√≠sticas en esta versi√≥n:
          - Mejorada UI responsiva del di√°logo de lectura de floppy
          - Eliminado prefijo "[STDERR]" de mensajes de track
          - Reset autom√°tico de GreaseWeazle al iniciar
          - Botones siempre visibles en todas las resoluciones
          - Layout optimizado con grid para mejor control
          
          ### üì¶ Binarios disponibles:
          - üçé **macOS**: `hp150-macos.zip`
          - ü™ü **Windows**: `hp150-windows.zip` 
          - üêß **Linux**: `hp150-linux.zip`
          
          ### üèÉ‚Äç‚ôÇÔ∏è C√≥mo ejecutar:
          1. Descarga el archivo para tu plataforma
          2. Extrae el ZIP
          3. Lee `HOW_TO_RUN.txt` para instrucciones espec√≠ficas
          
          ### üîß Modos disponibles:
          - **Extendido** (predeterminado): Funcionalidad completa
          - **B√°sico**: Agregar flag `--basic`
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
